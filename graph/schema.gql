type Space {
  uid: ID!
  name: String!
  description: String!
  traits: [Trait!]!
}

type Property {
  uid: ID!
  name: String!
  description: String!
}

type Trait {
  property: Property!
  value: Boolean!
  description: String!
}

type Theorem {
  uid: ID!
  if: String!
  then: String!
  description: String!
}

type Branch {
  name: String!
  access: String!
  sha: String!
}

type User {
  name: String!
  branches: [Branch!]!
}

type Viewer {
  spaces: [Space!]!
  properties: [Property!]!
  theorems: [Theorem!]!
  version: String!
}

type ResetBranchResponse {
  branch: String!
  sha: String!
}

# Inputs

input CreateSpaceInput {
  name: String!
  description: String!
}

input CreatePropertyInput {
  name: String!
  description: String!
}

input AssertTraitInput {
  spaceId: String!
  propertyId: String!
  value: Boolean!
}

input AssertTheoremInput {
  antecedent: String!
  consequent: String!
  description: String!
}

input ResetBranchInput {
  branch: String!
  to: String!
}

input UpdateSpaceInput {
  uid: String!
  description: String!
}

input UpdatePropertyInput {
  uid: String! 
  description: String!
}

input UpdateTheoremInput {
  uid: String!
  description: String!
}

input PatchInput {
  branch: String!
  sha: String!
}

# Root types

type Query {
  me: User!
  viewer(version: String): Viewer!
}

type Mutation {
  createSpace(patch: PatchInput!, space: CreateSpaceInput!): Viewer!
  createProperty(patch: PatchInput!, property: CreatePropertyInput!): Viewer!
  updateSpace(patch: PatchInput!, space: UpdateSpaceInput!): Viewer!
  updateProperty(patch: PatchInput!, property: UpdatePropertyInput!): Viewer!
  updateTheorem(patch: PatchInput!, theorem: UpdateTheoremInput!): Viewer!
  assertTrait(patch: PatchInput!, trait: AssertTraitInput!): Viewer!
  assertTheorem(patch: PatchInput!, theorem: AssertTheoremInput!): Viewer!
  resetBranch(input: ResetBranchInput!): ResetBranchResponse!
}

schema {
  query: Query
  mutation: Mutation
}